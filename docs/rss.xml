<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Fklightdog</title><link>https://Fklightdog.github.io</link><description>大三学生，目前学习C++和Go</description><copyright>Fklightdog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://Fklightdog.github.io</link></image><lastBuildDate>Tue, 24 Sep 2024 09:45:02 +0000</lastBuildDate><managingEditor>Fklightdog</managingEditor><ttl>60</ttl><webMaster>Fklightdog</webMaster><item><title>asio网络编程(6) 利用队列实现全双工</title><link>https://Fklightdog.github.io/post/asio-wang-luo-bian-cheng-%286%29%20-li-yong-dui-lie-shi-xian-quan-shuang-gong.html</link><description>本文是学习[**恋恋风辰Zack**](https://space.bilibili.com/271469206)asio网络编程的学习记录&#13;
之前的博客文章的异步服务器API，有提到利用队列写出来的API，所以此刻我们用队列来完善我们的服务器，实现全双工。</description><guid isPermaLink="true">https://Fklightdog.github.io/post/asio-wang-luo-bian-cheng-%286%29%20-li-yong-dui-lie-shi-xian-quan-shuang-gong.html</guid><pubDate>Tue, 24 Sep 2024 09:43:20 +0000</pubDate></item><item><title>asio网络编程(5) 伪闭包延长连接生命周期</title><link>https://Fklightdog.github.io/post/asio-wang-luo-bian-cheng-%285%29%20-wei-bi-bao-yan-chang-lian-jie-sheng-ming-zhou-qi.html</link><description>本文是学习[**恋恋风辰Zack**](https://space.bilibili.com/271469206)asio网络编程的学习记录&#13;
在上一节，我们可以看到双重析构的风险，因此我们在此节来改善这个问题，我们此处采用的方式是智能指针来延长我们Session的声明周期&#13;
下面我们来逐步修改,优先修改Server类&#13;
### Server类&#13;
我们先从start_server函数开始&#13;
```cpp&#13;
Session(boost::asio::io_context&amp; ioc, Server* server)//此处的Session构造函数改了&#13;
void Server::start_accept()&#13;
{&#13;
	std::shared_ptr&lt;Session&gt; new_session = std::make_shared&lt;Session&gt;(ioc, this);&#13;
	acceptor.async_accept(new_session-&gt;Socket(),&#13;
		[this, new_session](const boost::system::error_code&amp; error)&#13;
		{&#13;
			handle_accept(new_session, error);&#13;
		});&#13;
}&#13;
```&#13;
我们此处要用智能指针来代替最开始new出来的Session，顺带我们把回调函数也进行修改了，因为回调函数原本的new_session也是new出来的。</description><guid isPermaLink="true">https://Fklightdog.github.io/post/asio-wang-luo-bian-cheng-%285%29%20-wei-bi-bao-yan-chang-lian-jie-sheng-ming-zhou-qi.html</guid><pubDate>Mon, 23 Sep 2024 10:04:30 +0000</pubDate></item><item><title>asio网络编程(4) asio官方异步服务器案例的搭建</title><link>https://Fklightdog.github.io/post/asio-wang-luo-bian-cheng-%284%29%20asio-guan-fang-yi-bu-fu-wu-qi-an-li-de-da-jian.html</link><description>本文是学习[**恋恋风辰Zack**](https://space.bilibili.com/271469206)asio网络编程的学习记录&#13;
### 代码示例&#13;
本文服务器框架风格为**C++03的example**，C++11的example与C++03example相比，只是多了**Lambada表达式和smart_ptr**，大体上的风格还是非常相似的。</description><guid isPermaLink="true">https://Fklightdog.github.io/post/asio-wang-luo-bian-cheng-%284%29%20asio-guan-fang-yi-bu-fu-wu-qi-an-li-de-da-jian.html</guid><pubDate>Sun, 22 Sep 2024 06:58:01 +0000</pubDate></item><item><title>asio网络编程(3) 异步服务器的API</title><link>https://Fklightdog.github.io/post/asio-wang-luo-bian-cheng-%283%29%20-yi-bu-fu-wu-qi-de-API.html</link><description>本文是学习[**恋恋风辰Zack**](https://space.bilibili.com/271469206)asio网络编程的学习记录&#13;
本文建议可以直接阅读[**Zack的博客**](https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2O0QikntG7ktdgARRndYzNg8R55)，说的很详细。</description><guid isPermaLink="true">https://Fklightdog.github.io/post/asio-wang-luo-bian-cheng-%283%29%20-yi-bu-fu-wu-qi-de-API.html</guid><pubDate>Sat, 21 Sep 2024 09:35:34 +0000</pubDate></item><item><title>asio网络编程(2) 同步服务器和客户端的创建</title><link>https://Fklightdog.github.io/post/asio-wang-luo-bian-cheng-%282%29%20-tong-bu-fu-wu-qi-he-ke-hu-duan-de-chuang-jian.html</link><description>## 同步服务器和客户端的搭建&#13;
本文是学习[恋恋风辰Zack](https://space.bilibili.com/271469206)asio网络编程的学习记录&#13;
### 客户端的搭建&#13;
示例代码：&#13;
```cpp&#13;
#include&lt;boost/asio.hpp&gt;&#13;
#include &lt;iostream&gt;&#13;
constexpr int MAX_LENGTH = 1024;&#13;
using namespace boost::asio::ip;&#13;
int main()&#13;
{&#13;
	try&#13;
	{&#13;
		boost::asio::io_service ioc;&#13;
		tcp::socket socket(ioc);&#13;
		tcp::endpoint ep(address::from_string('127.0.0.1'), 10086);&#13;
		boost::system::error_code error = boost::asio::error::host_not_found;&#13;
		socket.connect(ep, error);&#13;
		if (error)&#13;
		{&#13;
			std::cout &lt;&lt; 'Connect failed, The code is' &lt;&lt; error.value() &#13;
				&lt;&lt; 'The message is' &lt;&lt; error.message() &lt;&lt; '\n';&#13;
			return 0;&#13;
		}&#13;
&#13;
		std::cout &lt;&lt; 'Enter the message\n';&#13;
		char request[MAX_LENGTH];&#13;
		std::cin.getline(request, MAX_LENGTH);&#13;
		std::size_t request_length = std::strlen(request);&#13;
		boost::asio::write(socket, boost::asio::buffer(request, request_length));&#13;
&#13;
		char reply[MAX_LENGTH];&#13;
		std::size_t reply_length = boost::asio::read(socket, boost::asio::buffer(reply, request_length));&#13;
		std::cout &lt;&lt; 'Reply is: ';&#13;
		std::cout.write(reply, reply_length);&#13;
		std::cout &lt;&lt; '\n';&#13;
		getchar();&#13;
&#13;
	}&#13;
	catch (const std::exception&amp; e)&#13;
	{&#13;
		std::cerr &lt;&lt; 'Expection:' &lt;&lt; e.what() &lt;&lt; '\n';&#13;
	}&#13;
	return 0;&#13;
}&#13;
```&#13;
对于客户端而言我们先创建上下文io_context，利用上下文来创建socket，然后我们用endpoint来创建终端节点，来connect服务器,最后我们调用boost::asio::read和boost::asio::write函数来进行读写操作&#13;
### 服务器的搭建&#13;
服务器的操作相比较客户端而言，复杂得多，我们先给出示例代码,然后再进行分析&#13;
```cpp&#13;
#include&lt;boost/asio.hpp&gt;&#13;
#include &lt;iostream&gt;&#13;
#include&lt;cstdlib&gt;&#13;
#include&lt;set&gt;&#13;
#include&lt;memory&gt;&#13;
using namespace boost::asio::ip;&#13;
using namespace std;&#13;
constexpr int max_length = 1024;&#13;
typedef shared_ptr&lt;tcp::socket&gt; socket_ptr; //定义一个socket指针类型&#13;
std::set&lt;shared_ptr&lt;std::thread&gt;&gt; thread_set;//定义一个线程集合&#13;
&#13;
void session(socket_ptr sock)&#13;
{&#13;
	try&#13;
	{	&#13;
		while (1)&#13;
		{&#13;
			char data[max_length];&#13;
			memset(data, '\0', max_length);&#13;
			boost::system::error_code error;&#13;
			//如果调用read()函数，会直到读取到max_length个字节或者对方关闭连接才会返回，这样会导致阻塞&#13;
			size_t length = sock-&gt;read_some(boost::asio::buffer(data, max_length), error);&#13;
			if (error == boost::asio::error::eof)&#13;
			{&#13;
				std::cout &lt;&lt; 'The connection closed by pear' &lt;&lt; '\n';&#13;
				break;&#13;
			}&#13;
			else if (error)&#13;
			{&#13;
				throw boost::system::system_error(error);&#13;
			}&#13;
&#13;
			std::cout &lt;&lt; 'Received form the ip:' &lt;&lt; sock-&gt;remote_endpoint().address().to_string() &lt;&lt; '\n';&#13;
			std::cout &lt;&lt; 'The message is' &lt;&lt; data &lt;&lt; '\n';&#13;
			boost::asio::write(*sock, boost::asio::buffer(data, length));&#13;
		}&#13;
	}&#13;
	catch (const std::exception&amp; e)&#13;
	{&#13;
		std::cerr &lt;&lt; 'Exception in thread: ' &lt;&lt; e.what() &lt;&lt; '\n' &lt;&lt; std::endl;&#13;
	}&#13;
}&#13;
&#13;
void server(boost::asio::io_context&amp; ioc, unsigned short port_num)&#13;
{&#13;
	tcp::acceptor acceptor(ioc, tcp::endpoint(tcp::v4(), port_num));&#13;
	while (1)&#13;
	{&#13;
		socket_ptr socket(new tcp::socket(ioc));&#13;
		acceptor.accept(*socket);&#13;
		auto t = std::make_shared&lt;std::thread&gt;(session, socket);&#13;
		thread_set.insert(t);&#13;
	}&#13;
}&#13;
&#13;
int main()&#13;
{&#13;
	try&#13;
	{&#13;
		boost::asio::io_context ioc;&#13;
		unsigned short port_num{ 10086 };&#13;
		server(ioc, port_num);&#13;
&#13;
		for (auto&amp; t : thread_set)&#13;
		{&#13;
			t-&gt;join();&#13;
		}&#13;
	}&#13;
	catch (const std::exception&amp; e)&#13;
	{&#13;
		std::cerr &lt;&lt; 'Exception: ' &lt;&lt; e.what() &lt;&lt; '\n';&#13;
	}&#13;
	return 0;&#13;
}&#13;
```&#13;
整个代码可以分成三部分：&#13;
* session()函数，对每一个进行连接的客户端创建一个会话&#13;
* server()函数，启动服务器，分配线程&#13;
* main()函数，调用server函数，最后手动的关闭所有正常进行的线程&#13;
&#13;
#### session()函数部分：&#13;
```cpp&#13;
&#13;
void session(socket_ptr sock)&#13;
{&#13;
	try&#13;
	{	&#13;
		while (1)&#13;
		{&#13;
			char data[max_length];&#13;
			memset(data, '\0', max_length);&#13;
			boost::system::error_code error;&#13;
			//如果调用read()函数，会直到读取到max_length个字节或者对方关闭连接才会返回，这样会导致阻塞&#13;
			size_t length = sock-&gt;read_some(boost::asio::buffer(data, max_length), error);&#13;
			if (error == boost::asio::error::eof)&#13;
			{&#13;
				std::cout &lt;&lt; 'The connection closed by pear' &lt;&lt; '\n';&#13;
				break;&#13;
			}&#13;
			else if (error)&#13;
			{&#13;
				throw boost::system::system_error(error);&#13;
			}&#13;
&#13;
			std::cout &lt;&lt; 'Received form the ip:' &lt;&lt; sock-&gt;remote_endpoint().address().to_string() &lt;&lt; '\n';&#13;
			std::cout &lt;&lt; 'The message is' &lt;&lt; data &lt;&lt; '\n';&#13;
			boost::asio::write(*sock, boost::asio::buffer(data, length));&#13;
		}&#13;
	}&#13;
	catch (const std::exception&amp; e)&#13;
	{&#13;
		std::cerr &lt;&lt; 'Exception in thread: ' &lt;&lt; e.what() &lt;&lt; '\n' &lt;&lt; std::endl;&#13;
	}&#13;
}&#13;
```&#13;
总体的逻辑是：我们对一个客户端一直进行读写操作，直到发生了异常。</description><guid isPermaLink="true">https://Fklightdog.github.io/post/asio-wang-luo-bian-cheng-%282%29%20-tong-bu-fu-wu-qi-he-ke-hu-duan-de-chuang-jian.html</guid><pubDate>Fri, 20 Sep 2024 09:05:13 +0000</pubDate></item><item><title>asio网络编程(1) socket的创建和连接</title><link>https://Fklightdog.github.io/post/asio-wang-luo-bian-cheng-%281%29%20socket-de-chuang-jian-he-lian-jie.html</link><description>本文是学习[恋恋风辰Zack](https://space.bilibili.com/271469206)asio网络编程的学习记录&#13;
## socket的监听和连接&#13;
### 网络编程&#13;
&#13;
&lt;p align='center'&gt;&#13;
  &lt;img src='https://cdn.llfc.club/1540562-20190417002428451-62583604.jpg' alt='图片描述'&gt;&#13;
  &lt;br&gt;&#13;
  网络编程流程图&#13;
&lt;/p&gt;&#13;
&#13;
对于服务器而言，流程如下：&#13;
* socket() --创建服务器套接字&#13;
* bind() --连接IP和端口号&#13;
* listen() --使套接字处于监听模式，使其准备接受来自客户端的连接&#13;
* accept() -- 如果传入连接的请求队列不为空，就从队列中取出一个连接请求，创建一个新的套接字，与客户端进行连接&#13;
&#13;
对于客户端而言，流程如下：&#13;
* socket() --创建客户端套接字&#13;
* connect() -- 与服务器进行连接&#13;
&#13;
两者共有的有：&#13;
* write() --进行写入操作&#13;
* read() --进行读取操作&#13;
&#13;
&#13;
### 终端节点的构造&#13;
在使用asio库进行网络编程的时候，我们应该优先构造终端节点，因为终端节点定义了网络通信的来源和目标，其包含了目标的ip和端口号。</description><guid isPermaLink="true">https://Fklightdog.github.io/post/asio-wang-luo-bian-cheng-%281%29%20socket-de-chuang-jian-he-lian-jie.html</guid><pubDate>Thu, 19 Sep 2024 09:12:23 +0000</pubDate></item><item><title>Learn the ways of Linux-fu，for free -- Permissions</title><link>https://Fklightdog.github.io/post/Learn%20the%20ways%20of%20Linux-fu%EF%BC%8Cfor%20free%20--%20Permissions.html</link><description>该文章为学习[*Learn the ways of Linux-fu，for free*](https://linuxjourney.com/)的记录，本文为*Permissions*&#13;
### 文件权限&#13;
对于Linux系统而言，每个文件都有自己的权限&#13;
```bash&#13;
$ ls -l Desktop/&#13;
drwxr-xr-x 2 pete penguins 4096 Dec 1 11:45 .&#13;
```&#13;
上述中的drwxr-xr-x为权限描述符，开头的d表示这是一个文件夹，而其他文件会以-开头，除了开头字母以为，其他元素以3bits来进行分割，如下&#13;
`d|rwx|r-x|r-x`&#13;
对于第一个3bits组而言表示的是个人权限，其次为小组权限，最后为其他用户的权限&#13;
对于上述的每个字符的含义如下：&#13;
&#13;
- r:代表可读权限&#13;
- w：代表可写权限&#13;
- x：代表可执行权限&#13;
&#13;
### 修改权限&#13;
我们可以使用 **chmod** 语句进行权限的修改，我们可以用 **+** 或者 **-** 号进行权限的增加和删除，下面为例子：&#13;
```bash&#13;
$ chmod u+x a.txt&#13;
$ chmod u-w a.txt&#13;
```&#13;
其中u表示user&#13;
除此之外我们也可以利用数字来进行修改，利用数字我们可以一口气把所有权限都进行修改，包括：用户权限、组权限和其他用户的权限。</description><guid isPermaLink="true">https://Fklightdog.github.io/post/Learn%20the%20ways%20of%20Linux-fu%EF%BC%8Cfor%20free%20--%20Permissions.html</guid><pubDate>Sun, 15 Sep 2024 13:11:58 +0000</pubDate></item><item><title>Text</title><link>https://Fklightdog.github.io/post/Text.html</link><description>Hello World。</description><guid isPermaLink="true">https://Fklightdog.github.io/post/Text.html</guid><pubDate>Fri, 13 Sep 2024 06:54:53 +0000</pubDate></item></channel></rss>